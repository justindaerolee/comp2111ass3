\documentclass[headings=small,a4paper,12pt]{scrartcl}
\usepackage{nicefrac}
\usepackage{2111defs2}
%
%\newcommand{\sorted}[3]{\mathit{s'ed}(#1[#2..#3])}
\newcommand{\sort}[3]{\mathit{sort}(#1[#2..#3])}
\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\newcommand{\bfs}{\textsc{breath first search}\xspace}
\newcommand{\srh}{\textsc{search}\xspace}
\newcommand{\qu}{\textsc{queue}\xspace}
%
\title{Derivation of $\bfs$\\
\large COMP2111 assignment 3}
%
\author{Dae Ro Lee z5060887 and Wing Feng z5091907}
\allowdisplaybreaks
%
\begin{document}
\maketitle
%
\section{Introduction}
\label{sec:introduction}
The derivation of $\bfs$ on a tree using a bounded $\qu$. 
%
\section{The Derivation}
\label{sec:derivation}
%
\begin{align*}
  &\PROC~\srh(\VALUE~t, \VALUE~N, \VALUE~k, \RESULT~v, \RESULT~f)\cdot{}\\
   &\qquad  \nt{t,N,k,v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t_0}(k_{t_0}(w)=k_0\And\lambda_{t_0}(w)=v))\Or\\
     (\Not f\And\forall w\in V_{t_0}(k_{t_0}(w)\neq~k_0))
    \end{array}
  \right]}{(1)}\\
%
  \lrefstep{(1)}
  {\textbf{c-frame}}
  {v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t}(k_t(w)=k\And\lambda_t(w)=v))\Or\\
     (\Not f\And\forall w\in V_t(k_t(w)\neq~k))
    \end{array}
  \right]}\\
  \refstep{\textbf{introduce local variable}}
  {\VAR~q, n\cdot{}\nt{q,n,v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t}(k_t(w)=k\And\lambda_t(w)=v))\Or\\
     (\Not f\And\forall w\in~V_t(k_t(w)\neq~k))
    \end{array}
  \right]}{(2)}}\\
\end{align*}
%---the following are format for invariant, can be moved to correct position later
\text We define the loop invariant for $\bfs$ as:\\
\begin{align*}
    {I:=\left(
      \begin{array}{l}
       % the visited here means the visited set which should be introduced before
      \left(
	  \begin{array}{l}
		\Not f \And 0 \leqslant n \leqslant N \And K_t(tmp) \neq k\\
		\Or (f\And  K_t(tmp) = k \And \lambda_t(tmp) = v)
        \end{array}
	  	\right)\\
     	 \And \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))
	\end{array}
    \right)}\\
\end{align*}
%---
\break
\begin{align*}
\lrefstep{(2)}{seq}	
{
	\nt{q,n,v,f:[\pre(2), I] }{(3)}\\
	&;\nt{q,n,v,f:[I, \post(2)] }{(4)}\\
 }\\			
%
\lrefstep{(3)}{seq}	
{
	\nt{q,n,v,f:[\pre(3), \pre(3)\And q=<>\And \Not f] }{(5)}\\
	&;\nt{q,n,v,f:[\pre(3)\And q=<>\And \Not f,I] }{(6)}\\
 }\\			
%
\lrefstep{(5)}{ass}	
{
	q := initialise(N);~f := \Not f\\
 }\\			
%
\lrefstep{(6)}{i-loc}	
{
	\VAR~tmp\cdot{}\nt{tmp,q,n,v,f:[\pre(3)\And q=<>\And \Not f,I] }{(7)}\\
 }\\			
 \refstep{\textbf{ass}}
{
	q := dequeue()\\
	& n := 0\\
}\\
%
\lrefstep{(4)}{while}	
{
	\WHILE~n \neq 0 \And \Not f ~\DO:
 }\\		
\end{align*}
%---following are queue operation
Define the following queue operation:\\
\textbf{initialise:} initialise a queue that can hold up to \textit{N} elements to the empty queue vlaue.
\begin{align*}
  &\PROC~initialise(N,\RETURN q)\cdot{}\\
\end{align*}
\break
\textbf{enqueue:} adds an item to a queue if there's a space available 
\begin{align*}
  &\PROC~enqueue(q, \VALUE~v,n)\cdot{}\\
    &\qquad n,q:[n<N \And q=q_0\And q \neq <>,q=q_0\cup\{v\}]\\
%
  \refstep{\textbf{}}
  {}
\end{align*}
%
\textbf{dequeue:} return the oldest item in the queue and remove it form the queue\\
\break
\textbf{isempty:} return whether a queue is empty
\begin{align*}
  &\PROC~isempty(n, \RETURN f)\cdot{}\\
    &\qquad {n,f:[n \in \mathbb{Z^+} ,(\Not f \And n \neq 0)\Or (f \And n = 0)]}\\
\end{align*}
\break

\end{document}
