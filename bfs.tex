\documentclass[headings=small,a4paper,12pt]{scrartcl}
\usepackage{nicefrac}
\usepackage{2111defs2}
\usepackage{amsmath}
%
%\newcommand{\sorted}[3]{\mathit{s'ed}(#1[#2..#3])}
\newcommand{\sort}[3]{\mathit{sort}(#1[#2..#3])}
\newcommand{\pre}{\mathit{pre}}
\newcommand{\post}{\mathit{post}}
\newcommand{\bfs}{\textsc{breath first search}\xspace}
\newcommand{\srh}{\textsc{search}\xspace}
\newcommand{\qu}{\textsc{queue}\xspace}
\newcommand{\enq}{\textsc{enqueue}\xspace}
\newcommand{\deq}{\textsc{dequeue}\xspace}
\newcommand{\ini}{\textsc{initialise}\xspace}
%
\title{Derivation of $\bfs$\\
\large COMP2111 assignment 3}
%
\author{Dae Ro Lee z5060887 and Wing Feng z5091907}
\allowdisplaybreaks
%
\begin{document}
\maketitle
%
\section{Introduction}
\label{sec:introduction}
The derivation of $\bfs$ on a tree using a bounded $\qu$. 
%
%---following are queue operation
We extend the toy language with queues and queue operations, and operations on abstract queues, which we eliminate later with data refinement. 
\begin{align*}
    &Q(\tau) ::= \langle\rangle\qquad\text{(empty queue)}\\
    &|\qquad\langle~x,t~\rangle\qquad\text{where $x\in\tau$ and $t\in~Q(\tau)$}\\
    &|\qquad\langle~t,x~\rangle\\
\end{align*}
We define the following queue operation:\\
\textbf{initialise:} initialise a queue that can hold up to \textit{N} elements to the empty queue value.
\begin{align*}
  &\ini\qquad~q :[\True, q = \langle\rangle] \isrefinedby q\Ass \langle\rangle
\end{align*}
\textbf{\enq:} adds an item to a queue if there's a space available 
\begin{align*}
  &\enq\qquad q:[\True, q=\langle q_0,x\rangle]\isrefinedby \enq(q,x)
\end{align*}
\textbf{\deq:} return the oldest item in the queue and remove it form the queue\\
\begin{align*}
 %   &\deq\qquad n,q:[n>0\And q=\langle s,qp\rangle\And q\ne~\langle\rangle, s= s_0\And q = qp] \isrefinedby qp \Ass \deq(q) 
	&\deq\qquad q,x:[q = <a,b>, x = a \And q = b] \isrefinedby x \Ass \deq(q) 
\end{align*}
We do the data refinement to take the abstract queue to a more concrete representation using circular buffer, that is an array \textit{r} of  \textit{N+1} cells and two counters \textit{h} and \textit{t} for which \textit{h} = 0 and \textit{t} = -1 when \textit{r} is empty, otherwise \textit{h mod (N+1)} and \textit{t mod (N+1)}  the head and tail indexs of \textit{r} which represents the head and tail of the queue.\\
%
Using the Reynolds method, the coupling invariant would be:\\
\begin{align*}
	&C: Q(V_t) \times V^*_t \times \mathbb{N}  &\to & \mathbb{B}\\
	&C(<>,r,h,t)  &=  &(t - h+1 = 0)\\
	&C(<q,x>,r,h,t) &= &(r[t\mod (N+1)]=x \And C(q,r,h,t))\\
	&C(<x,q>,r,h,t) &= &(x = r[h\mod (N+1)] \And C(q,r,h,t))
\end{align*}
For $\ini$ operations:\\
\begin{align*}
	 &\nt{q,r,h,t:[\True, q=<> \And C(<>,r,h,t)]}{(I_1)}\\
%
	\lrefstep{(I_1)}
	{\textbf{seq}} 
	{
 		 \nt{q:[\True,q=<>] }{(I_2)}\\
 		 &;\nt{r,h,t:[q=<>, q=<> \And C(<>,r,h,t)]] }{(I_3)}\\
	 }\\    
%   
	\lrefstep{(I_2)}
	{\textbf{\ini}} 
	{
 		 q:=<> \\
	 }\\   
%   
	\lrefstep{(I_3)}
	{\textbf{ass}} 
	{
 		 h := 0 ;~t := -1
	 }\\    
\end{align*}
\break
\section{The Derivation}
\label{sec:derivation}
%
\begin{align*}
  &\PROC~\srh(\VALUE~t, \VALUE~N, \VALUE~k, \RESULT~v, \RESULT~f)\cdot{}\\
   &\qquad  \nt{t,N,k,v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t_0}(k_{t_0}(w)=k_0\And\lambda_{t_0}(w)=v))\Or\\
     (\Not f\And\forall w\in V_{t_0}(k_{t_0}(w)\neq~k_0))
    \end{array}
  \right]}{(1)}\\
%
  \lrefstep{(1)}
  {\textbf{c-frame}}
  {v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t}(k_t(w)=k\And\lambda_t(w)=v))\Or\\
     (\Not f\And\forall w\in V_t(k_t(w)\neq~k))
    \end{array}
  \right]}\\
  \refstep{\textbf{introduce local variable}}
  {\VAR~q, n\cdot{}\nt{q,n,v,f:\left[
    \begin{array}{l}
     \forall x\in V_t(x\in \Gamma^{*}_{t}(r_t)\And x \notin\Gamma^{+}_{t}(x))\And\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N,\\
     (f\And\exists w\in V_{t}(k_t(w)=k\And\lambda_t(w)=v))\Or\\
     (\Not f\And\forall w\in~V_t(k_t(w)\neq~k))
    \end{array}
  \right]}{(2)}}\\
\end{align*}
%---the following are format for invariant, can be moved to correct position later
\section{Invariant}
\label{sec:invariant}
\text We define the loop invariant for $\bfs$ as:\\
\begin{align*}
    &I = \left(
    \begin{array}{l}
         \exists j\in \mathbb{N}\cdot{}(\forall~x \in \Gamma^{\forall~i<j}(r_t)\cdot{}K_t(x) \ne k)\\
         \And 0\leq~n\leq~N\And \exists~l\in[0,n-1] \cdot{}q[0..l] \subseteq \Gamma^j_t(r_t)\\
         \And q[l+1..n-1] \subseteq \Gamma^{j+1}_t(r_t)\\
         \And (\forall y\in V_t(y\in \Gamma^{*}_{t}(r_t)\And y \notin\Gamma^{+}_{t}(y)))\\
         \And ((f\And\exists~s\in \Gamma^{j}_{t}(r_t)\cdot{}k_t(s) = k\And \lambda_t(s) = v\And s\notin q)\\
         \Or (\Not~f \And \forall~p \in \Gamma^j_t(r_t) \And p\notin~q \And k_t(p) \ne k \And \Gamma_t(p) \subseteq q))
    \end{array}
    \right)\\
\end{align*}
$j$ is defined as the distance from the root node, to the current node.
\\
The first line of the invariant shows that all previous levels of the tree before the node most recently $\deq$ has given a false when checked.\\
the second line and third line of the invariant show that the queue, $q$ is composed of only two levels of the tree at any given time.\\
Since $0\leq~n\leq~N$, and $n$ is described as the length of the queue\\ $\max_{i\in\mathbb{N}}|\Gamma_t^{i}(r_t)\cup\Gamma_{t}^{i+1}(r_t)|\leq N$, of the precondition implies the second and third line of the invariant. Showing that $n$ the length of the queue cannot exceed the number of nodes of two consecutive levels of the tree\\
The invariant also contains the fact that all nodes are connected as a tree data structure, identical to that in the precondition.\\
\\
$I\And(f\Or~n=0)$, When $f=\True$ the invariant describes that some node,\\ $s\in\Gamma^j_t(r_t)\cdot{}k_t(s) = k\And \lambda_t(s) = v\And s\notin q$, which implies the post condition in the scenario that $f = \True$\\
In the case that $f=\False\And~n=0$ the first and last line of the invariant shows that all nodes previous to current level have been checked.\\ Since the queue is empty all nodes on the current level have also been checked implying that none of the nodes in the tree contain the key that we are looking for,\\ implying the post condition in the scenario that $n=0$.\\
Therefore $I\And(f\Or~n=0)$ implies the post condition\\
%---
\break
\section{The Derivation continued ...}
\label{sec:derivation2}
\begin{align*}
\lrefstep{(2)}
{\textbf{seq} no initial variables} 
{
  \nt{q,n,v,f:[\pre(2), I] }{(3)}\\
  &;\nt{q,n,v,f:[I, \post(2)] }{(4)}\\
 }\\
\end{align*}
%
We derive code by initialising $f$ to $\False$ and $\enq$ the root node to establish our invariant initially.
%
\begin{align*}
\lrefstep{(3)}
{\textbf{seq} no initial variables} 
{
  \nt{q,n,v,f:[\pre(3), \pre(3)\And q=<>\And \Not f] }{(5)}\\
  &;\nt{q,n,v,f:[\pre(3)\And q=<>\And \Not f,I] }{(6)}\\
 }\\      
%
\lrefstep{(5)}
{\textbf{ass}} 
{
  q \Ass initialise();\\
  &f \Ass \False\\
 }\\      
%
\lrefstep{(6)}
{\textbf{ass}} 
{
  \enq(q,r_t);\\
  & n \Ass 1\\
}\\
%
\lrefstep{(4)}
{\textbf{s-post}}
{q,n:[I\And~g, I\And (f \Or~ q=<>)]}\\
%
\refstep{\textbf{\WHILE}} 
{
  \WHILE~n \neq 0 \And \Not f ~\DO\\
      &\qquad \nt{q,n:[I\And~n\ne~0\And\Not~f, I]}{(7)}\\
  &\OD
 }\\  
%
 \lrefstep{(7)}
 {\textbf{i-loc}}
 {\VAR~tmp\cdot{}\nt{tmp,q,n:[I\And~n\ne~0\And\Not~f, I]}{(8)}}\\
%
 \lrefstep{(8)}
 {\textbf{seq}}
 {\nt{tmp,n,q:[g\And~I\And~q=<z,qt>, q=qt\And tmp=z]}{(a)}\\
 &;\nt{tmp,n,q:[q=qt\And tmp=z, I]}{(b)}}\\
%
 \lrefstep{(b)}
 {\textbf{if}}
 {\IF~k_t(tmp) = k~\THEN\\
 &\qquad~\nt{f,v:[\NOT~f\And k_t(tmp) = k, I]}{(c)}\\
 &\ELSE\\
 &\qquad \nt{[k_t(tmp) \ne k, I]}{(d)}\\
 &\FI}\\
%
\lrefstep{(a)}
{\textbf{ass}}
{tmp \Ass \deq(q,n)}\\
\end{align*}
%
To make the invariant $\True$ if $k_t(tmp) = k$, we have to assign $f \Ass \True$ because the sixth line of the invariant tell us that $f$ cannot be $\False$ when $k_t(tmp) = k$.\\
Now make the fifth line of the invariant true assign\\ $\lambda_t(tmp) = v$ such that the invariant is $True$.\\
%
\begin{align*}
\lrefstep{(c)}
{\textbf{ass}}
{f\Ass \True;\\
&v = \lambda_t(tmp)}\\
%
\end{align*}
Because $tmp$ is not the node we are looking for, we now have to make sure the conditions of the invariant are met. The invariant tells us that $q$ contains up-to two levels of the tree at any given time. We also know that since $tmp$ has been $\deq$ from $q$, $tmp \notin q$, hence the end of the 5th line of the invariant tells us that the children of all the nodes that are on the current level but not in $q$ must be a subset of $q$, therefore all the children of $tmp$ have to be added to $q$ to meet the invariant\\

\begin{align*}
    \lrefstep{(d)}
    {\textbf{...}}
    {\WHILE~m \ne \emptyset~\DO\\
    &\qquad\VAR~c:\in~m\\
    &\qquad\enq(q,c)\\
    &\qquad n \Ass n+1\\
    &\qquad m\Ass m\backslash\{c\}\\
    &\OD\\}
\end{align*}
%
\section{Code}
\label{sec:code}
Putting the code together we have
\begin{align}
    &\textcolor{red}{\VAR~q\Ass\langle\rangle}\\
    &\VAR~n:\mathbb{N}\Ass 0\\
    &f\Ass \False\\
    &\textcolor{red}{\enq(q,r_t)}\\
    &n\Ass 1\\
    &\WHILE~n \ne 0\And \Not f~\DO\\
    &\textcolor{red}{\qquad \VAR~tmp\Ass \deq(q,n)}\\
    &\qquad n\Ass n-1\\
    &\qquad \IF~k_t(tmp) = k~\THEN\\
    &\qquad\qquad f\Ass \True\\
    &\qquad\qquad v\Ass \lambda_t(tmp)\\
    &\qquad \ELSE\\
    &\qquad\qquad \VAR~m\Ass \Gamma_t(tmp)\\
    &\qquad\qquad\WHILE~m \ne \emptyset~\DO\\
    &\qquad\qquad\qquad\VAR~c:\in~m\\
    &\textcolor{red}{\qquad\qquad\qquad\enq(q,c)}\\
    &\qquad\qquad\qquad n \Ass n+1\\
    &\qquad\qquad\qquad m\Ass m\backslash\{c\}\\
    &\qquad\qquad\OD\\
    &\qquad\FI\\
    &\OD
\end{align}
Text in \textcolor{red}{red} are abstract queue operations.\\
\section{MAYBE RUBBISH}
\label{sec:rubbish}
include that children of tmp do not exist in q in precondition\\
\begin{align*}
\lrefstep{(d)}
{\textbf{i-loc}}
{\VAR~m\cdot{} \nt{[k_t(tmp) \ne k, q= q_0\cdot{}\Gamma~(tmp)]}{(d_1)}}\\
%
\lrefstep{(d_1)}
{\textbf{s-post}}
{m,tmp,q:[k_t(tmp) \ne k, \Gamma_t(tmp) \subseteq q]}\\
%
\refstep
{\textbf{seq}}
{\nt{m,q,tmp:[k_t(tmp) \ne k, \Gamma_t(tmp) \subseteq m\cup q]}{(e)}\\
&\nt{m,tmp,q:[\Gamma_t(tmp) \subseteq m\cup q, \Gamma_t(tmp) \subseteq q]}{(f)}}\\
%
\lrefstep{(e)}
{\textbf{ass}}
{\VAR~m\Ass\Gamma_t(tmp)}\\
%
\lrefstep{(f)}
{\textbf{\WHILE}}
{\WHILE~m\ne~\emptyset~\DO\\
&\qquad~\nt{m,tmp,q:[\Gamma_t(tmp)\subseteq m\cup~q\And m\ne\emptyset,\Gamma_t(tmp)\subseteq m\cup~q]}{(g)}\\
&\OD}\\
%
\lrefstep{(g)}
{\textbf{i-loc}}
{\VAR~c\cdot{}\nt{c,m,tmp,q:[\Gamma_t(tmp)\subseteq m\cup~q\And m\ne\emptyset,\Gamma_t(tmp)\subseteq m\cup~q]}{(h)}}\\
%
\lrefstep{(h)}
{\textbf{seq}}
{c,m,tmp,q:[\Gamma_t(tmp)\subseteq m\cup~q\And m\ne\emptyset,\Gamma_t(tmp)\subseteq m\cup~q]}
\end{align*}\\
We prove that the precondition to the procedure search implies the invariant
\begin{align*}
    &I\subst{1}{n}\subst{\langle\rangle}{q}\subst{\False}{f}\subst{\langle\rangle}{q}\\
    &=  \exists j\in \mathbb{N}\cdot{}(\forall~x \in \Gamma^{\forall~i<j}(r_t)\cdot{}K_t(x) \ne k)\\
    &\And 0\leq~1\leq~N\And\langle\rangle \subseteq \Gamma^0_t(r_t)\\
    &\And (\forall y\in V_t(y\in \Gamma^{*}_{t}(r_t)\And y \notin\Gamma^{+}_{t}(y)))\\
    &\And\forall~p \in \Gamma^0_t(r_t) \And p\notin~\langle\rangle \And k_t(p) \ne k)
\end{align*}\\
most of the invariant is made redundant by the fact that the q is substituted by an empty set and the because f is substituted by $\False$. The only value that $j$ can be is $0$.\\
\end{document}
